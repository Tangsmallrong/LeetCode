# Link_list 知识点

## 基础知识

**链表**是⼀种通过指针串联在⼀起的线性结构：

- **基本特性**：链表由一系列节点组成，每个节点包含**数据域和指针**域。数据域存储数据元素，指针域存储指向下一个节点的指针。这种结构允许在不连续的内存空间中存储数据
- **头节点**：链表的入口节点称为头节点（head）。在某些实现中，可能会有一个哨兵节点/虚拟头节点（dummy head）作为链表的首元素，以简化边界条件的处理
- **尾节点**：最后一个节点的指针域指向`NULL`，表示链表的结束

**链表的存储方式**：

- **非连续存储**：链表的节点在内存中是非连续存储的，每个节点可以独立地分配在内存的任意位置。节点之间通过指针相连。

## 链表的类型

- **单向链表**：每个节点只包含指向下一个节点的指针。遍历通常从头节点开始，只能向一个方向进行
- **双向链表**：节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。这允许链表可以双向遍历
- **循环链表**：链表的尾节点指向头节点，形成一个环。循环链表可以是单向也可以是双向的，可以⽤来解决约瑟夫环问题

## 单链表节点的定义

### 节点定义

单链表的节点可以通过结构体（`struct`）或类（`class`）来定义。对于简单的链表结构，结构体通常就足够了。

```c++
struct ListNode {
    int val;            // 数据域
    ListNode *next;     // 指针域，指向下一个节点
    // 构造函数
    ListNode(int x) : val(x), next(nullptr) {}
    // 默认构造函数
    ListNode() : val(0), next(nullptr) {}
};
```

> **注意**：如果不定义构造函数使⽤默认构造函数的话，在初始化的时候就不能直接给变量赋值

### 节点初始化

- **直接在构造时初始化（推荐）**

当你创建节点时已经知道数据域的值时，可以直接使用带参数的构造函数进行初始化。这样做的优点是代码简洁，且可以在创建对象的同时完成所有必要的初始化。

```c++
ListNode* node = new ListNode(5); // 创建一个值为5的节点，next指针自动初始化为nullptr
```

- **使用默认构造函数后手动赋值**

如果某些情况下，节点的数据域的值需要稍后确定，或者需要基于一些条件动态计算，那么可以先使用默认构造函数创建节点，随后手动为数据域赋值。

```cpp
ListNode* node = new ListNode(); // 使用默认构造函数创建节点
node->val = 5;                   // 手动为数据域赋值
```

## 链表的操作

- **遍历**：访问链表中的每个节点，根据链表的类型，遍历可以是单向或双向。
- **添加节点**：可以在链表的头部、尾部或中间的任何位置添加新节点。添加操作的时间复杂度通常是O(1)，但如果需要找到特定位置，则可能需要O(n)的时间复杂度。
- **删除节点**：同样，可以删除链表中的任何节点。直接的删除操作时间复杂度是O(1)，但找到特定节点可能需要O(n)的时间。
- **搜索**：查找链表中是否存在具有特定值的节点。这通常需要O(n)的时间复杂度。

# 经典题目

> 感觉大部分题目用 虚拟头节点+双指针 都能解决

## 链表基本操作

- 包括插入节点、删除节点、遍历链表等基础操作
- 时间复杂度：
  - (已知位置)插入和删除 O(1)
  - 搜索和访问 O(n)

## 虚拟头节点

- 简化边界条件处理，特别是在插入和删除操作中
- 创建一个额外的节点(dummy head)作为链表的新头部，这个虚拟头节点的 `next` 指向原始链表的头节点

## 双指针解法

- **快慢指针**：如检测环，查找链表中点等问题
  - **环形链表**：快指针每次移动两步，慢指针每次移动一步 ==> 快慢指针+公式推导 时间复杂度：O(n)
  - **寻找链表中点**：快指针每次移动两步，慢指针每次移动一步，时间复杂度 O(n)
- **前后指针**：如反转链表，删除倒数第N个节点等问题
  - **反转链表**：双指针逐步后移反转，一个指针跟踪当前节点，另一个跟踪前一个节点，用于实现链表的反转
    - 迭代法 时间复杂度：O(n)
    - 递归法 时空复杂度：O(n)
  - **删除倒数第N个节点**：快指针先于慢指针前进N步 ==> 时间复杂度：O(n)
  - **链表相交**：双指针同步遍历 时间复杂度：O(m+n)

# 其他链表题目

Q2 两数相加

**Q19 删除链表的倒数第 N 个结点**	

Q21 合并两个有序链表	

Q23 合并K个升序链表	

**Q24 两两交换链表中的节点**	

Q25 K 个一组翻转链表	

Q61 旋转链表	

Q83 删除排序链表中的重复元素	

Q82 删除排序链表中的重复元素 II	

**Q92 反转链表 II**	

Q138 复制带随机指针的链表	

**Q160 相交链表**	

Q146 LRU 缓存机制	

**Q203 移除链表元素**	

Q430 扁平化多级双向链表	

Q460 LFU 缓存	

Q725 分隔链表	

Q1600 皇位继承顺序	



