[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

## Description

给定正整数 `n` ，要求将 `1` 到 `n^2` 所有元素按顺时针顺序螺旋排列填入 `n x n` 正方形矩阵中并返回该矩阵

**示例：**

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

解释：
1 → 2 → 3	
        ↓
8 → 9	4
↑ 	↓
7 ← 6 ← 5
```

**提示：**`1 <= n <= 20`

## Solution

**核心思想**：**模拟** 螺旋矩阵的生成过程，通过顺时针方向逐步填充矩阵的每一个元素

- **初始化状态**：定义一个二维 `vector` `nums` 作为结果矩阵，其大小为 `n x n`，所有元素初始值默认为0。设置起始填充位置 `(startX, startY)` 为 `(0, 0)`，初始化填充的数字 `count` 为1。定义 `offset` 来表示每次填充后边界的收缩量，初始值为1。
- **螺旋填充过程**：通过一个外层循环来控制矩阵的螺旋填充，每次循环完成矩阵的一圈填充。在每一圈中，分别对上、右、下、左四个方向进行填充，每填充一个元素，`count` 自增1。这四个方向的填充通过四个内层循环实现，确保按照顺时针方向进行。
  - **上边填充**：从左向右填充顶行，不包括最后一个元素（因为它将由右边填充）。
  - **右边填充**：从上向下填充最右列，不包括最后一个元素（因为它将由下边填充）。
  - **下边填充**：从右向左填充底行，不包括最后一个元素（因为它将由左边填充）。
  - **左边填充**：从下向上填充最左列，包括起始点但不包括终点（因为它已被上边填充）。
- **边界更新**：每完成一圈螺旋填充后，起始位置 `(startX, startY)` 向内移动一格（即各自增加1），同时 `offset` 也增加1，以缩小下一次循环的填充范围。
- **中心元素处理**：对于奇数 `n` 的情况，最中心的元素无法通过上述四个方向的循环被填充，因此在循环结束后需要单独对其赋值。

### C++_code

```c++
vector<vector<int>> generateMatrix(int n) {
    int startX = 0, startY = 0;  // 起始位置
    int offset = 1;  // 控制缩小范围
    int count = 1;  // 填充的数字
    // 初始化二维 vector 分配空间 n*n
    vector<vector<int>> nums(n, vector<int>(n));

    while (offset <= (n / 2)) {  // n^2 个数, 需至少循环 n / 2 圈
        // 4 个循环, 遍历 4 条边
        // 顺时针: 上右下左
        int i, j;

        // 上
        for (j = startY; j < n - offset; j++) {
            nums[startX][j] = count++;
        }

        // 右
        for (i = startX; i < n - offset; i++) {
            nums[i][j] = count++;
        }

        // 下
        for ( ; j > startY; j--) {
            nums[i][j] = count++;
        }

        // 左
        for ( ; i > startX; i--) {
            nums[i][j] = count++;
        }

        // 起始位置++, 偏移量++
        startX++;
        startY++;
        offset++;
    }

    // 如果 n 为奇数, 则还需要对中间元素单独赋值
    if (n % 2 == 1) {
        nums[startX][startY] = count++;
    }

    return nums;
}
```

### Java_code

```java
public int[][] generateMatrix(int n) {
    int[][] nums = new int[n][n];
    int startX = 0, startY = 0;
    int offset = 1, count = 1;

    while (offset <= (n / 2)) {
        int i, j;

        // 上
        for (j = startY; j < n - offset; j++) {
            nums[startX][j] = count++;
        }

        // 右
        for (i = startX; i < n - offset; i++) {
            nums[i][j] = count++;
        }

        // 下
        for ( ; j > startY; j--) {
            nums[i][j] = count++;
        }

        // 左
        for ( ; i > startX; i--) {
            nums[i][j] = count++;
        }

        startX++;
        startY++;
        offset++;
    }

    if (n % 2 == 1) {
        nums[startX][startY] = count++;
    }

    return nums;
}
```

## Conclusion

### 时空复杂度

**时间复杂度**： **O(n^2)**

- 这里的 `n` 指的是矩阵的维度。虽然外层循环看起来只迭代了 `n / 2` 次（每次处理一圈，圈数大约是矩阵宽度的一半），但实际上，内层的四个循环（上、右、下、左）累计遍历了矩阵中的所有 `n^2` 个元素，每个元素恰好被访问一次来进行赋值
- 因此，总的操作数与矩阵中的元素数量成正比，即 `n^2`

**空间复杂度**：**O(n^2)**

- 算法主要消耗的空间是用来存储结果的二维 `vector`，它的大小为 `n x n`
- 除此之外，算法使用的额外空间（如循环中的计数器和索引变量）是常量级的，因此在空间复杂度分析中可以忽略不计

### 补充知识

在算法解题中，**模拟**和**循环不变量**是两种常用的思想：

**模拟（Simulation）** 基本使用思路：

- **分解问题**：将问题分解为多个小步骤或阶段，每个步骤对应问题描述中的一部分。
- **逐步实现**：根据问题的逻辑，逐步实现每个步骤，确保每一步都正确模拟了问题描述中的相应部分。
- **维护状态**：在模拟过程中，维护和更新所有相关的状态信息，以确保模拟的准确性。

**循环不变量（Loop Invariant）** 基本使用思路：

- **确定不变量**：在循环或递归之前，确定一个条件或性质作为不变量，它在每次迭代或递归调用之前和之后都保持为真。
- **初始化不变量**：在循环或递归开始前，确保不变量成立。
- **保持不变量**：在循环体或递归函数中的每一步操作，确保不改变不变量的真实性。这通常涉及到正确地更新状态变量。
- **利用不变量**：循环结束或递归完成后，使用不变量的性质来得出算法的正确性或结果的正确性。













