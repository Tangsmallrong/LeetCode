[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)

## Description

给定数组 nums 和⼀个值 val，编写函数**原地**移除所有数值等于 val 的元素，并返回移除后数组的新⻓度。

要求：不使⽤额外的数组空间，仅使⽤ O(1) 并**原地**修改输⼊数组。

元素的顺序可以改变，不需要考虑数组中超出新长度后面的元素。

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,3,0,4]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。
```

 **提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

## Solution

### 暴力解法

两层 for 循环，⼀个 for 循环遍历数组元素 ，第⼆个 for 循环更新数组，时间复杂度是 O(n^2)

```c++
int removeElement(vector<int>& nums, int val) {
    int size = nums.size();
    for (int i = 0; i < size; i++) {
        if (nums[i] == val) {  // 发现需要移除的元素，就将数组集体向前移动⼀位
            for (int j = i + 1; j < size; j++) {
                nums[j - 1] = nums[j];
            }
            i--;  // 因为下标i以后的数值都向前移动了⼀位，所以i也向前移动⼀位
            size--;  // 此时数组的⼤⼩-1
        }
    }
    return size;
}
```

### 双指针法(快慢双指针)

- **初始化两个指针**：`slow` 和 `fast` 都从数组的起始位置 `0` 开始。`slow` 指针用于跟踪下一个不等于给定值 `val` 的元素应该插入的位置，而 `fast` 指针用于遍历数组中的每个元素。
- **遍历数组**：使用 `fast` 指针遍历数组。对于每个元素，我们检查它是否等于给定的值 `val`。
  - 如果当前元素 `nums[fast]` **不等于** `val`，说明这个元素需要保留。我们将它复制到 `nums[slow]` 的位置，然后递增 `slow` 指针。这一步是在“原地”修改数组，将需要保留的元素移动到数组的前面。
  - 如果当前元素等于 `val`，则不需要做任何操作，`fast` 指针继续向前移动，检查下一个元素。
- **重复直到数组遍历完成**：重复上述步骤，直到 `fast` 指针遍历完数组中的所有元素。这个过程中，`slow` 指针前面的所有元素都是不等于 `val` 的元素。
- **返回新长度**：最后，`slow` 指针的位置就是移除了所有等于 `val` 的元素后，数组的新长度。
  - `slow` 指针的最终位置有两种可能的情况：
    - **如果数组中存在等于 `val` 的元素**，那么在完成所有的移动操作后，所有不等于 `val` 的元素都被重新排列在数组的前端，而 `slow` 指针则标记着这些元素之后的第一个位置，既不包含值为 `val` 的新数组长度的位置。
    - **如果数组中不存在等于 `val` 的元素**，那么在遍历完数组后，`slow` 指针将停留在数组的末尾，即数组长度的位置。

#### C++_code

```c++
int removeElement(vector<int>& nums, int val) {
    int slow = 0;  // 慢指针，跟踪下一个不等于val的元素应该插入的位置

    // 快指针fast用于遍历数组
    for (int fast = 0; fast < nums.size(); fast++) {
        if (nums[fast] != val) {  // 如果当前元素不等于val
            nums[slow] = nums[fast];  // 将它复制到slow指针的位置
            slow++;  // 移动slow指针，为下一个可能的不等于val的元素预留位置
        }
        // 如果当前元素等于val，快指针fast会继续前进，而slow指针保持不动
    }

    return slow;
}
```

#### Java_code

```java
public int removeElement(int[] nums, int val) {
    int slow = 0;

    for (int fast = 0; fast < nums.length; fast++) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast];
            slow++;
        }
    }

    return slow;
}
```

#### 时空复杂度

**时间复杂度：O(n)**

- 对于数组中的每个元素，`fast`指针都会进行一次比较操作（是否等于`val`），并根据比较结果可能执行一次赋值操作（当元素不等于`val`时）。因此，对于长度为`n`的数组，循环体内的操作会执行`n`次。
- 每次操作的时间可以认为是常数时间`O(1)`，包括比较和赋值操作。因此，总的时间复杂度是`n`次操作乘以每次操作的时间，即`O(n) * O(1) = O(n)`。

**空间复杂度：O(1)**

- 除了输入数组之外，只使用了几个变量（`slow`和`fast`指针，以及循环中的临时变量），这些额外的存储空间不随输入数组的大小`n`变化，是固定的。
- 算法的额外空间需求不随输入数据的大小而改变，满足题目对于**原地操作（即不使用额外数组空间）**的要求。

### 双指针优化(无序数组)

针对题目中并无对结果数组的顺序要求，可以进行以下优化：

- **优化方法一**：同时从数组的开头和末尾向中间遍历，当**遇到需要移除的元素时，直接用数组末尾的元素替换它**，然后减少数组的长度
  - 该方法可以减少了不必要的元素移动，特别是**当要移除的元素较少且分布不均时**，提高效率
  - 时间复杂度是 O(n)，其中 n 为序列的长度

```c++
int removeElement(vector<int>& nums, int val) {
    int left = 0, right = nums.size();
    while (left < right) {
        if (nums[left] == val) {
            nums[left] = nums[right - 1];
            right--;
        } else {
            left++;
        }
    }
    return left;
}
```

- **优化方法二**：通过两个指针从两端向中间遍历，当**左边找到一个需要移除的元素，右边找到一个不需要移除的元素时，就将它们交换**。这样可以减少需要移动的元素数量，特别是当数组中需要移除的元素集中在一侧时。
  - 在`val`**元素较多且分布不均时可能更有效**
  - 时间复杂度在最坏情况下（即所有需要移除的元素都集中在一端）可能会接近O(n)，但如果`val`元素均匀分布，效率可能会稍低于直接的双指针方法，因为存在额外的比较和交换操作

```c++
int removeElement(vector<int>& nums, int val) {
    if (nums.empty()) {
        return 0;
    }
    int l = 0;
    int r = nums.size() - 1;
    while (l <= r) {
        // 找左边等于val的元素
        while (l <= r && nums[l] != val) {
            l++;
        }
        // 找右边不等于val的元素
        while (l <= r && nums[r] == val) {
            r--;
        }
        // 将右边不等于val的元素覆盖左边等于val的元素
        if (l < r) {
            // 这里移动指针是可选的，因为下一次循环会再次检查，但可以减少迭代次数
            swap(nums[l++], nums[r--]);    
        }
    }
    
    return l;
}
```

## Conclusion

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖**

