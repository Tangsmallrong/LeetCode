[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

## Description

给定一个按 **非递减顺序** 排序的整数数组 `nums`，要求返回 **每个数字的平方** 后也按 **非递减顺序** 排序后组成的新数组

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**提示：**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **非递减顺序** 排序

## Solution

### 暴力解法

把每个数平方之后再排序，时间复杂度为 `O(nlogn)`

- 对数组中的每个元素进行平方，这一步的时间复杂度是`O(n)`；在C++中，`sort` 函数通常实现为快速排序，其平均情况下的时间复杂度是`O(nlogn)`

```c++
vector<int> sortedSquares(vector<int>& nums) {
    for (int i = 0; i < nums.size(); i++) {
        nums[i] *= nums[i];
    }
	// 快排
    sort(nums.begin(), nums.end());

    return nums;
}
```

### 双指针解法

利用**输入数组已经是按非递减顺序排序**的这一特点(所以数组两端的数平方后可能是最大的)，我们可以更高效地生成结果数组，而无需额外的排序步骤。两种双指针策略：

#### 从中心向两端移动的双指针

首先找到非负数开始的位置作为中心点，然后设置两个指针分别向左（处理负数）和向右（处理非负数）移动，比较两个指针所指元素的平方值，**将较小的平方值按顺序填入结果数组**，时间和空间复杂度：`O(n)`

```c++
vector<int> sortedSquares(vector<int>& nums) {
    int n = nums.size();
    int negative = -1;  // 找到最后一个负数的位置
    for (int i = 0; i < n; ++i) {
        if (nums[i] < 0) {
            negative = i;
        } else {
            break;  // 找到第一个非负数即退出循环
        }
    }

    vector<int> ans;
    int i = negative, j = negative + 1;  // i从最后一个负数开始，j从第一个非负数开始
    while (i >= 0 || j < n) {
        if (i < 0) {  // 如果负数部分已经处理完，只处理非负数部分
            ans.push_back(nums[j] * nums[j]);
            ++j;
        }
        else if (j == n) {  // 如果非负数部分已经处理完，只处理负数部分
            ans.push_back(nums[i] * nums[i]);
            --i;
        }
        else if (nums[i] * nums[i] < nums[j] * nums[j]) {  // 比较负数部分和非负数部分哪个平方值更小
            ans.push_back(nums[i] * nums[i]);
            --i;
        }
        else {
            ans.push_back(nums[j] * nums[j]);
            ++j;
        }
    }

    return ans;
}
```

#### 从两端向中心移动的双指针

通过设置两个指针，分别指向数组的起始和终点，比较两个指针所指元素的平方值，**将较大的平方值按顺序填入结果数组的末尾**，然后移动相应的指针，时间和空间复杂度：`O(n)`

- **使用双指针遍历数组**：使用两个指针`i`和`j`从`nums`数组的两端向中间遍历。
- **比较并存储平方值**：在每一步中，比较`nums[i]`和`nums[j]`的平方值。由于数组是非递减顺序排序的，最大的平方值可能来自于数组的两端。我们将较大的平方值存入`result`数组中`k`指向的位置，并相应地移动`i`或`j`指针（如果`nums[i]`的平方大，则增加`i`；否则，减少`j`）。之后，我们将`k`减少1，以便在下一次迭代中填充下一个最大的平方值。
- **循环直到指针相遇**：这个过程一直持续到`i`和`j`相遇，此时数组`nums`的所有元素都已经考虑过并按照平方值的非递减顺序存储在`result`数组中。
- **返回结果**：最后，返回填充完成的`result`数组。

```c++
vector<int> sortedSquares(vector<int>& nums) {
    int size = nums.size();
    vector<int> result(size);
    int k = size - 1, i = 0, j = k;

    while (i <= j) {
        // 比较i位置和j位置元素的平方大小
        if (pow(nums[i], 2) > pow(nums[j], 2)) {
            // 如果i位置的元素平方大于j位置的元素平方
            // 则将i位置元素的平方赋值给结果数组的k位置
            // 并将k指针前移一位，i指针后移一位
            result[k--] = pow(nums[i], 2);
            i++;
        } else {
            result[k--] = pow(nums[j], 2);
            j--;
        }
    }

    return result;
}
```

- Java 版本：

```java
public int[] sortedSquares(int[] nums) {
    int len = nums.length;
    int k = len - 1, i = 0, j = k;
    int[] result = new int[len];

    while (i <= j) {
        if (nums[i] * nums[i] > nums[j] * nums[j]) {
            result[k--] = nums[i] * nums[i];
            i++;
        } else {
            result[k--] = nums[j] * nums[j];
            j--;
        }
    }

    return result;
}
```

## Conclusion

双指针解法：

- **时间复杂度**：通过单次遍历来同时完成所有元素的平方计算及其排序工作，遍历的过程中每个元素都被访问一次，因此时间复杂度是`O(n)`，其中`n`是数组`nums`的长度。

- **空间复杂度**：需要一个大小与输入数组`nums`相同的数组`result`来存储结果，因此空间复杂度为`O(n)`

双指针法的一些通用解法和适用场景的总结：

- **类型**
  - **快慢指针**：快慢指针一般用于解决链表中的问题，如检测循环、寻找中点或判断链表长度。快指针的移动速度是慢指针的两倍，通过两者的相对速度差解决问题。
  - **左右指针**：左右指针主要用于处理数组或字符串，特别是排序数组或字符串的问题。这种方法常用于二分查找、双向扫描等场景。
- **适用场景**
  - **对撞指针**：当需要在数组中寻找两个元素的组合（如和为特定值）时，如果数组已排序，可以使用一前一后两个指针向中间移动，根据两指针指向值的和来调整指针位置。
  - **滑动窗口**：用于解决数组/字符串的子元素组合问题，如找出满足条件的最短子数组、计算字符串中的不同字符等。通过维护一个动态的窗口，根据条件扩大或缩小窗口大小。
  - **链表中环的检测**：使用快慢两个指针遍历链表，如果两指针相遇，则链表存在环。
  - **有序数组的二分查找**：虽然严格来说是一种二分策略，但可以视为一种特殊的双指针应用，通过调整左右指针的位置来缩小查找范围。
  - **合并两个有序数组**：从两个数组的末尾元素开始比较，选择较大的元素放入合并后数组的末尾，逐步向前。





























