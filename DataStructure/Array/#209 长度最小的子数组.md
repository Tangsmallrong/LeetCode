[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/)

## Description

给定一个含有 `n` 个正整数的数组和一个正整数 `target` ，找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组**，并返回其长度，如果不存在符合条件的子数组，返回 `0` 。

**示例：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

 **进阶：** 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

## Solution

### 暴力解法

2层for循环遍历数组的所有区间情况，外层循环控制起始位置，内层循环控制终止位置，枚举所有情况，直到和大于等于 `target` 或子数组达到数组的末尾

- 时间复杂度：O(n^2)，其中 n 是数组的长度。
- 空间复杂度：O(1)，只使用了常数空间。

```c++
int minSubArrayLen(int target, vector<int> &nums) {
    int minLen = INT_MAX; // 最小长度初始化为最大整数

    for (int i = 0; i < nums.size(); i++) {
        int sum = 0; // 每次开始新的子数组时重置sum
        for (int j = i; j < nums.size(); j++) {
            sum += nums[j];
            if (sum >= target) {
                minLen = min(minLen, j - i + 1); // 更新最小长度
                break;                           // 已找到满足条件的子数组，跳出内层循环
            }
        }
    }

    if (minLen == INT_MAX) {
        return 0; // 如果minLen没有被更新，说明没有符合条件的子数组
    }

    return minLen;
}
```

### 前缀和+二分查找

**这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性**。

首先通过计算前缀和，将问题转化为寻找两个位置 `i` 和 `j`，使得从 `i` 到 `j` 的子数组和至少为 `target`。然后，对于每个可能的起点 `i`，我们使用二分查找来快速定位满足条件的最短子数组的终点 `j`。

最后，我们在所有找到的满足条件的子数组中选择最短的一个，并返回其长度。如果没有找到满足条件的子数组，就返回 0。

- **计算前缀和**：首先，我们创建一个大小为原数组长度加一的 `sums` 数组，用于存储前缀和。`sums[i]` 表示原数组 `nums` 的前 `i` 个元素的和。这样，任意子数组 `nums[i...j]` 的和可以通过 `sums[j+1] - sums[i]` 快速计算得出。
- **初始化最小长度**：设置一个变量 `minLen` 用于记录满足条件的最短子数组的长度，初始值设为 `INT_MAX`，代表一个非常大的数。
- **遍历寻找最短子数组**：对于每个可能的起点 `i`（通过前缀和数组 `sums` 表示），计算包含该起点且和至少为 `target` 的子数组的最短长度。这是通过查找第一个使得 `sums[j] - sums[i] >= target` 的位置 `j` 来完成的。
- **使用二分查找**：为了找到满足条件的最小的 `j`，我们在 `sums` 数组中使用 `std::lower_bound` 进行二分查找。我们查找的目标值是 `target + sums[i]`，这表示我们想找到的是第一个使得子数组和大于等于 `target` 的终点 `j`。
- **更新最小长度**：如果找到了这样的位置，我们更新 `minLen` 为找到的子数组长度 (`index - i`) 与当前 `minLen` 中的较小值。
- **返回结果**：遍历完成后，检查 `minLen` 是否为 `INT_MAX`，如果是，说明没有找到满足条件的子数组，返回 0；否则，返回 `minLen`。

```c++
int minSubArrayLen(int target, vector<int>& nums) {
    int length = nums.size();
    int minLen = INT_MAX;
    vector<int> sums(length + 1, 0);

    // 计算前缀和
    for (int i = 1; i <= length; ++i) {
        sums[i] = sums[i - 1] + nums[i - 1];
    }

    // 遍历寻找最短子数组
    // 对于每个可能的起点 i（通过前缀和数组表示）, 计算包含该起点且和至少为 target 的子数组的最短长度
    for (int i = 0; i <= length; ++i) {
        int toFind = target + sums[i];
        // 二分查找, 找的目标值是 target + sums[i], 找到第一个使得子数组和大于等于 target 的终点 j
        // lower_bound 返回一个指向给定序列中的一个元素的迭代器, 这个元素是序列中第一个不小于（即大于或等于）搜索值的元素
        vector<int>::iterator bound = lower_bound(sums.begin(), sums.end(), toFind);

        if (bound != sums.end()) {  // 如果找到
            // 计算迭代器 bound 指向的元素在 sums 数组（或向量）中的索引
            // 相减得两个迭代器之间的距离, 得到了 bound 指向的元素在 sums 数组中的索引位置
            int index = bound - sums.begin();  

            minLen = min(minLen, index - i);  // 更新 minLen 为找到的子数组长度 (index - i) 与当前 minLen 中的较小值
        }
    }
    return minLen == INT_MAX ? 0 : minLen;
}
```

### 双指针滑动窗口解法

通过动态调整一个窗口的大小来找到满足条件的最短子数组。开始时，两个指针都位于数组的起始位置，然后逐渐向右移动右指针扩大窗口，直到窗口内的元素总和大于等于 `target`。此时，尝试通过移动左指针缩小窗口，以寻找更短的满足条件的子数组。

- **遍历数组**：使用右指针 (`j`) 遍历数组中的每个元素，执行以下操作：
  - **累加当前和**：将右指针指向的元素加到 `sum` 上，以此来扩展窗口的右边界。
  - **调整左指针**：当 `sum`（当前窗口内元素的总和）大于等于目标值 (`target`) 时，执行以下操作：
    - 计算当前子数组的长度 (`len = j - i + 1`)，并与已记录的最短长度 (`result`) 进行比较，取两者中的较小值更新为新的最短长度。
    - 从 `sum` 中减去左指针指向的元素的值，然后将左指针向右移动一位（`i++`），以此来缩小窗口的左边界，并尝试找到更短的满足条件的子数组。
- **循环直至遍历完成**：重复上述过程，直到右指针完成对数组的遍历。这一过程中，我们不断调整左指针和右指针，以寻找并更新满足条件的最短子数组长度。

- **返回结果**：遍历完成后，检查 `result` 的值：

  - 如果 `result` 的值仍然是 `INT_MAX`，说明没有找到满足条件的子数组，返回 `0`。

  - 否则，返回 `result`，即满足条件的最短子数组的长度。

```c++
int minSubArrayLen(int target, vector<int> &nums) {
    int i = 0, result = INT_MAX, sum = 0; 

    for (int j = 0; j < nums.size(); j++) {
        sum += nums[j];

        // 当sum大于等于target时, 尝试通过移动左指针缩小窗口, 直到窗口内的sum小于target
        while (sum >= target) {
            int len = j - i + 1;  // 计算当前满足条件的子数组长度
            result = min(len, result);  // 更新结果
            sum -= nums[i++];  // 计算完 len 之后再移动左指针并更新sum
        }
    }

    return result == INT_MAX ? 0 : result;
}
```

- Java 版本

```java
public int minSubArrayLen(int target, int[] nums) {
    int result = Integer.MAX_VALUE;
    int i = 0, sum = 0;
    
    for (int j = 0; j < nums.length; j++) {
        sum += nums[j];
        
        while (sum >= target) {
            int len = j - i + 1;
            result = Math.min(result, len);
            sum -= nums[i++];
        }
    }
    
    return result == Integer.MAX_VALUE ? 0 : result;
}
```

## Conclusion

### 时空复杂度分析

前缀和+二分查找的方法：

- **时间复杂度**：

  - **前缀和计算**：O(n)，其中 n 是数组 `nums` 的长度。我们需要遍历一次数组来计算所有元素的前缀和。

  - **二分查找应用**：对于每个元素，我们使用 `lower_bound` 进行二分查找，每次查找的时间复杂度为 O(log n)。因为我们需要对每个可能的起点执行一次二分查找，共有 n 个起点，所以这部分的总时间复杂度是 O(n log n)。

  - 因此，整体时间复杂度为 **O(n + n log n) = O(n log n)**。

- **空间复杂度**：

  - **前缀和数组**：O(n)，我们需要一个额外的数组来存储前缀和，这个数组的长度是原数组长度加一（为了方便处理，避免边界条件的复杂判断）。
  - **变量存储**：O(1)，除了前缀和数组外，我们只需要常数级别的空间来存储如最小长度 `minLen`、当前子数组的和等局部变量。
  - 因此，整体空间复杂度为 **O(n)**。

双指针滑动窗口的方法：

- **时间复杂度**：**O(n)**

  - **单次遍历**：尽管存在两个指针（左指针和右指针），整个数组或链表通常只需要被遍历一次。右指针负责向前探索新的元素以扩大窗口，而左指针则在条件满足时向前移动以缩小窗口或维持特定条件。

  - **指针移动**：每个指针（左指针和右指针）在整个算法过程中最多只会向前（向数组或链表的末尾方向）移动 **n** 次。这意味着每个元素最多被访问两次：一次是右指针向前移动时，另一次是左指针向前移动时。

  > 尽管内部有一个 while 循环嵌套在 for 循环中，但是整个算法过程中每个元素仅被访问常数次（最多两次）
  >
  > 通常情况下，嵌套循环的时间复杂度是两个循环次数的乘积，因为每次外循环都要完整执行一次内循环。然而在这里，内层 while 循环并不是每次外循环都要从头到尾执行。

  - 因此，尽管我们使用了两个指针，整个数组或链表的所有元素总的访问次数仍然是线性的，从而保证了 **O(n)** 的时间复杂度。

- **空间复杂度**：**O(1)**

  - **常数额外空间**：该方法主要依靠两个指针来控制窗口的大小和位置，而这两个指针只需要极少的额外空间（通常是两个变量来存储索引或指针位置）。

### 补充-滑动窗口

- **原理**
  - 滑动窗口的本质是一个队列，但与普通队列的先进先出（FIFO）原则不同，滑动窗口可以根据具体问题的需求调整其大小。
  - 双指针通常代表着窗口的边界，一个指向窗口的开始（左边界），另一个指向窗口的结束（右边界）。通过移动这两个指针，我们可以控制窗口的大小和位置。

- **应用**

  - **定长窗口问题**：当问题要求固定长度的连续子序列时，双指针可以维护一个固定大小的窗口。右指针向前移动以扩展窗口，当窗口达到所需大小后，左指针随之移动以保持窗口大小不变。

  - **变长窗口问题**：对于那些没有固定长度要求的问题，窗口的大小会根据当前遍历到的元素动态调整。这通常涉及到在满足或不满足某些条件时移动左指针或右指针，以此来找到符合条件的最优解。

以下是应用双指针滑动窗口策略的一般步骤：

- **初始化**：设定两个指针，通常是将它们都置于序列的起始位置。
- **窗口扩展**：移动右指针以探索更多的元素，直到窗口包含了一个潜在的有效解。
- **窗口收缩**：一旦找到了一个有效解，尝试通过移动左指针来缩小窗口大小，以寻找更小的有效解或满足题目要求的最优解。
- **更新结果**：在窗口移动的过程中，根据问题的需要更新最终的结果。
- **重复**：重复步骤2到4，直到右指针到达序列的末尾。



